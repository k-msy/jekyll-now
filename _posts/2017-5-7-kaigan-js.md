---
layout: post
title: 「開眼！JavaScript」で開眼できることは何か
---
GW最終日になんとか目標のひとつ「開眼！JavaScript」を読破できた！  
索引含めP.171だから、そこまで時間かからないだろうと、5時間見積もっていたが、終わって実績見てみるときっかり8時間。  

自分の見積もりの甘さは後々克服していくとして、この本は、私のこれまでのjsを見る目を大きく変えてくれた本だと思う。  

キーワードを先に書いておくと、  
「JavaScriptの9つのネイティブオブジェクト、プリミティブ型、値渡しと参照渡し、プロトタイプチェーン、スコープチェーン、プロトタイプ拡張、入れ子関数内のthis」といった感じ。  

**「オブジェクトとは、名前と値を持つプロパティを格納するコンテナにすぎない」**  

この言葉がすべての基本になっているように思う。  

以降、各章でメモを取ったことをいくつかピックアップしながら、必要に応じてコメントをば。  

<!-- more -->

### [ 1章：JavaScript オブジェクト ]  
- 「オブジェクトとは、名前と値を持つプロパティを格納するコンテナにすぎない」
- new演算子を使用しない場合、関数スコープ内のthisにはその関数を呼出したオブジェクトが設定される
- JavaScriptでは、プリミティブ型を除くほとんどの値にコンストラクタ関数によるオブジェクトの生成、もしくはインスタンス化が関わっている  
- JavaScriptの9つのネイティブオブジェクト  
  Number()
  String()
  Boolean()
  Object()
  Array()
  Function()
  Date()
  RegExp()
  Error()  
- プリミティブ値は値そのものを格納・比較していて、オブジェクトは参照を格納・比較している（同じオブジェクトへの参照をおこなっているか）  
  -> **値渡しと参照渡しの違い**  
- プリミティブ型の文字列、数値、真偽値はオブジェクトのように扱うとオブジェクトのようにふるまう  
  コンストラクタによって生成されたオブジェクトを使うようにプリミティブ型を使うと、JavaScriptはその命令を実行するためにプリミティブ値を一時的に
  オブジェクトに変換するらしい。（プリミティブ値を補完する「ラッパーオブジェクト」が生成されるとのこと）
  そのオブジェクトは命令が実行された後に破棄され、値はプリミティブ型に戻るとな。  
  裏で何をコソコソしとるんだという感じだが。  
  こういうとこJavaさんは融通しなさそうである。（丁寧にエラーを返そうなものである）
- 値を直接保持するプリミティブ型とは違い、オブジェクトは実体への参照を保持している。そのため、オブジェクトを他の変数に代入する場合、実際の
  値はコピーされず、そのオブジェクトの参照（アドレス）がコピーされる。  
  -> あるオブジェクトを変更した場合、そのオブジェクトを参照しているすべての変数も同時に変更されるということ  
  -> オブジェクトが参照渡しだということは、ほとんどすべてのオブジェクトに対して任意の時点で任意の変更を行うことができる  
  -> AngularとかVueとかのdata-bindingって、この仕様を上手いこと組み込んで実現しているのかなぁ。
- constructorプロパティはオブジェクトを生成したコンストラクタ関数をポイントしている。
  -> そのインスタンスがどのコンストラクタ関数で作られたものなのかが分かる  

といった感じで、1章でこの本の言いたいことの半分は言ってるんじゃないかと思うぐらい、とても大事なことが書いてあった。  

### [ 2章：オブジェクトとプロパティを扱う ]
- オブジェクト内に存在しないプロパティにアクセスしようとすると、JavaScriptは常にプロトタイプチェーンを辿って、そのプロパティを探し当てようとする
- すべてのオブジェクトインスタンスは、インスタンスを生成したコンストラクタ関数のprototypeプロパティにリンクする秘密のプロパティ（__proto__）を持っている  
  この秘密のリンクを使ってインスタンスのコンストラクタ関数のprototypeプロパティを取得することができる  
- プロパティがオブジェクト自身が保持するプロパティかどうか、またはプロトタイプチェーンから継承したプロパティかどうかを調べるには、hasOwnProperty()メソッドを使う  

### [ 4章：関数（Function( )）]  
- すべての関数は常に値を返す。return文を記述しない場合や、return文で戻り値を明示的に指定していない場合に返される値はundefined。

### [ 5章：グローバルオブジェクト ]
- var演算子を使って変数を宣言する際、jsはDontDelete属性を持ったプロパティを追加する。  
  対してvar演算子を使わずグローバルプロパティを新たに追加する場合、そのプロパティにはDontDelete属性が付かない  
  -> delete演算子で削除できちゃう。
- グローバルオブジェクトはスコープチェーンの最後に参照される場所。グローバルオブジェクトを明示的に指定しない場合でも、  
  常に暗黙的に指し示されているということを理解する必要がある  
  ※明示的にグローバルオブジェクトを指定すると、計算コストがほんのわずか上昇するらしい。  
   よって、使用する変数がグローバルスコープにあることがわかっているのであれば、グローバルオブジェクトを明示的に指定せず、
   スコープチェーンに任せた方が速く動作するらしい

### [ 6章：this ]
- 関数が宣言時とは別のコンテクストに存在する変数やプロパティに渡されて実行される場合など、関数が呼び出されるコンテクストによって  
  thisの値が変化することをよく覚えておく必要がある
- **thisが呼ばれる関数が他の関数に内包されている場合や、他の関数コンテクストからthisが呼ばれた場合には、  
  そのthisはグローバルオブジェクトを参照する。**  
  ネスト化された関数の中で呼んでるthisは、グローバルを指すんだと。なんでやねんとw  
  それを避けるために、ネスト化された関数の前にthatとかにthisを突っ込んで、そのネスト化された関数の中でthatを使うっていう方法が  
  あるらしいが、なんでそんなトンデモ仕様のために、わざわざそんな対応をしなければならないのか。  
  ちなみに、本書ではECMA5では修正されるよって書いてあったけど、Chromeのコンソールで確認しても修正されていなかった。  
  thisの挙動自体は変わってなくて、ワークアラウンドの方法が充実したということなのだろうか？ちょっと良く分かってない。。

### [ 8章：関数のprototypeプロパティ ]
- プロトタイプからプロパティを継承するインスタンスは常に最新の値を取得  
  -> prototypeプロパティは動的であると言える。  
- prototypeプロパティを新しいオブジェクトにまるごと置き換えた場合、それまでに生成したすべてのインスタンスが更新されることはない。
  -> インスタンスは **「インスタンス化時点のprototypeオブジェクトに紐付けられる」** から。  
  -> インスタンスによって異なるprototypeオブジェクトを参照することになるから、インスタンスを生成したコンストラクタ関数のprototypeを新しいオブジェクトに置き換えるのは避けるべき  
  -> 避けるべきってことで結論は出てるんだけど、この自由さがjsなんだなぁとしみじみ思ったりした。  

### [ 9章：配列（Array( )） ]
- Array()パラメータは、最大約42億個の引数を受け取ることができるが、引数が1つだけしか渡されず、且つ、その引数がJavaScriptによって  
  整数と判断される場合、その引数は配列のlengthの設定に使用され、要素として評価されることはない。
- 配列のlengthを元の要素数より少なくすると、範囲外の要素はすべて削除される。  

### [ 12章：Boolean( ) ]  
- Boolean()コンストラクタに生成された（プリミティブ型ではない）真偽値オブジェクトは、あくまでもオブジェクトであって、  
  たとえそれがfalseの値を持っているとしても、評価時にはtrueに変換されてしまう  
  （オブジェクトは、 **0, -0, null, false, NaN, undefined, 空文字**, のいずれでもないから）  
  ※もし真偽値ではない値を真偽値に変換したいのであれば、new演算子を使用せずにBoolean()に値を渡してくれとのこと。するとBoolean()はプリミティブ型(true or false)を返す。
- JavaScriptではどの値がfalseとしてみなされるのかどうかを知っておくことが重要  
  （それによって、どのような値がtrueとみなされるかが分かるから）  

### [ 13章：プリミティブ型文字列、数値、真偽値 ]
- typeof演算子の返す値は、値を生成した方法に依存から、文字列、数値、真偽値を判断するためにtypeof演算子を使っている場合は  
  特に、これらをオブジェクト型で宣言するのは避けるべき  
  - 文字列、数値、真偽値オブジェクトを生成した場合、typeofはobjectを返す
  - リテラルで値を生成した場合、それぞれの ‘string’, ’number’, ‘boolean’ を返す

### [ 14章：null ]
- null値を確認するためには、必ず同値演算子（===）を使用する。  
  ※等値演算子（==）はnullとundefinedを区別しない。  

### [ 15章：undefined ]  
- undefinedを変数に代入するのは避けて、JavaScriptだけがundefinedを使うようにするべき。
- 変数やプロパティがその時点で利用不可能であることを指定するには、undefinedではなくnullを使うべき。  

## jsはオブジェクト、オブジェクトは名前と値を持つプロパティを格納するコンテナ！
だから、 string も number も array も function も何もかも格納することができる。
推奨・非推奨あるけど、key も value の CRUD も自由自在という無法地帯がjsなのだというざっくりとした理解に至った。  

忘れた時に定期的に読み返したい読み物だった。
